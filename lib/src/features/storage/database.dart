import 'database.steps.dart';
import 'package:drift/drift.dart';
import 'package:drift_flutter/drift_flutter.dart';
import 'package:flutter/foundation.dart' show debugPrint, kDebugMode;
import 'package:path_provider/path_provider.dart';
import 'connection/connection.dart' as impl;

// Manually generated by `drift_dev make-migrations` - this file makes writing
// migrations easier. See this for details:
// https://drift.simonbinder.eu/docs/advanced-features/migrations/#step-by-step
import 'tables.dart';

// Generated by drift_dev when running `build_runner build`
part 'database.g.dart';

@DriftDatabase(tables: [Characters, CharacterPictures, RankedCharacters])
class AnimeDatabase extends _$AnimeDatabase {
  AnimeDatabase([QueryExecutor? e])
    : super(
        e ??
            driftDatabase(
              name: 'anime-character-tierlist-app',
              native: const DriftNativeOptions(
                databaseDirectory: getApplicationSupportDirectory,
              ),
              web: DriftWebOptions(
                sqlite3Wasm: Uri.parse('sqlite3.wasm'),
                driftWorker: Uri.parse('drift_worker.js'),
                onResult: (result) {
                  if (result.missingFeatures.isNotEmpty) {
                    debugPrint(
                      'Using ${result.chosenImplementation} due to unsupported '
                      'browser features: ${result.missingFeatures}',
                    );
                  }
                },
              ),
            ),
      );

  AnimeDatabase.forTesting(DatabaseConnection super.connection);

  @override
  int get schemaVersion => 2;

  Future<List<CharacterData>> getAllCharacters() async {
    final charactersQuery = select(characters);
    final List<CharacterData> allCharacters = [];

    final results = await charactersQuery.get();
    for (final characterRow in results) {
      final pictures =
          await (select(characterPictures)
            ..where((p) => p.characterId.equals(characterRow.id))).get();

      final rankedCharacterRow =
          await (select(rankedCharacters)
            ..where((p) => p.characterId.equals(characterRow.id))).get();
      final sortOrder =
          rankedCharacterRow.isNotEmpty
              ? rankedCharacterRow.first.sortOrder
              : 0;

      allCharacters.add(
        CharacterData(
          id: characterRow.id,
          animeId: characterRow.animeId,
          animeName: characterRow.animeName,
          name: characterRow.name,
          pictures: pictures.map((p) => Uri.parse(p.pictureUri)).toList(),
          sortOrder: sortOrder,
        ),
      );
    }

    return allCharacters;
  }

  Future<void> insertCharacter(
    CharacterData character,
    List<Uri> pictures,
  ) async {
    await transaction(() async {
      // Insert character first
      await into(characters).insert(
        CharactersCompanion(
          id: Value(character.id),
          animeId: Value(character.animeId),
          animeName: Value(character.animeName),
          name: Value(character.name),
        ),
      );

      // Insert pictures
      for (final pictureUri in pictures) {
        await into(characterPictures).insert(
          CharacterPicturesCompanion(
            characterId: Value(character.id),
            pictureUri: Value(pictureUri.toString()),
          ),
        );
      }
    });
  }

  Future<void> rankCharacter(int characterId, int rank) async {
    await into(rankedCharacters).insertOnConflictUpdate(
      RankedCharactersCompanion(
        characterId: Value(characterId),
        rank: Value(rank),
      ),
    );
  }

  Future<List<TierData>> getTiers() async {
    final query = select(rankedCharacters).join([
      innerJoin(
        characters,
        characters.id.equalsExp(rankedCharacters.characterId),
      ),
    ]);

    final results = await query.get();

    // Group results by rank
    final groupedResults = <int, List<CharacterData>>{};
    for (final row in results) {
      final characterRow = row.readTable(characters);
      final pictures =
          await (select(characterPictures)
            ..where((p) => p.characterId.equals(characterRow.id))).get();

      final rankedCharacterRow = row.readTable(rankedCharacters);
      final character = CharacterData(
        id: characterRow.id,
        animeId: characterRow.animeId,
        animeName: characterRow.animeName,
        name: characterRow.name,
        pictures: pictures.map((p) => Uri.parse(p.pictureUri)).toList(),
        sortOrder: rankedCharacterRow.sortOrder,
      );
      final rank = rankedCharacterRow.rank;
      groupedResults.putIfAbsent(rank, () => []).add(character);
    }

    return groupedResults.entries
        .map((entry) => TierData(rank: entry.key, characters: entry.value))
        .toList()
      ..forEach(
        (tier) =>
            tier.characters.sort((a, b) => a.sortOrder.compareTo(b.sortOrder)),
      )
      ..sort((a, b) => a.rank.compareTo(b.rank));
  }

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onUpgrade: stepByStep(
        from1To2: (m, schema) async {
          await m.addColumn(
            schema.rankedCharacters,
            schema.rankedCharacters.sortOrder,
          );
          await m.alterTable(TableMigration(schema.rankedCharacters));
        },
      ),
      beforeOpen: (details) async {
        // Make sure that foreign keys are enabled
        await customStatement('PRAGMA foreign_keys = ON');

        // This follows the recommendation to validate that the database schema
        // matches what drift expects (https://drift.simonbinder.eu/docs/advanced-features/migrations/#verifying-a-database-schema-at-runtime).
        // It allows catching bugs in the migration logic early.
        if (kDebugMode) {
          await impl.validateDatabaseSchema(this);
        }
      },
    );
  }
}

// Data classes for the API
class CharacterData {
  final int id;
  final int animeId;
  final String animeName;
  final String name;
  final List<Uri> pictures;
  final int sortOrder;

  const CharacterData({
    required this.id,
    required this.animeId,
    required this.animeName,
    required this.name,
    required this.pictures,
    required this.sortOrder,
  });
}

class TierData {
  final int rank;
  final List<CharacterData> characters;

  const TierData({required this.rank, required this.characters});
}
