import 'database.steps.dart';
import 'package:drift/drift.dart';
import 'package:drift_flutter/drift_flutter.dart';
import 'package:flutter/foundation.dart' show debugPrint, kDebugMode;
import 'package:path_provider/path_provider.dart';
import 'connection/connection.dart' as impl;

// Manually generated by `drift_dev make-migrations` - this file makes writing
// migrations easier. See this for details:
// https://drift.simonbinder.eu/docs/advanced-features/migrations/#step-by-step
import 'tables.dart';

// Generated by drift_dev when running `build_runner build`
part 'database.g.dart';

@DriftDatabase(tables: [Characters, CharacterPictures, RankedCharacters])
class AnimeDatabase extends _$AnimeDatabase {
  AnimeDatabase([QueryExecutor? e])
    : super(
        e ??
            driftDatabase(
              name: 'anime-character-tierlist-app',
              native: const DriftNativeOptions(
                databaseDirectory: getApplicationSupportDirectory,
                shareAcrossIsolates: true,
              ),
              web: DriftWebOptions(
                sqlite3Wasm: Uri.parse('sqlite3.wasm'),
                driftWorker: Uri.parse('drift_worker.js'),
                onResult: (result) {
                  if (result.missingFeatures.isNotEmpty) {
                    debugPrint(
                      'Using ${result.chosenImplementation} due to unsupported '
                      'browser features: ${result.missingFeatures}',
                    );
                  }
                },
              ),
            ),
      );

  AnimeDatabase.forTesting(DatabaseConnection super.connection);

  @override
  int get schemaVersion => 3;

  Future<List<CharacterData>> getAllCharacters() async {
    final charactersQuery = select(characters);
    final List<CharacterData> allCharacters = [];

    final results = await charactersQuery.get();
    for (final characterRow in results) {
      final pictures =
          await (select(characterPictures)
            ..where((p) => p.characterId.equals(characterRow.id))).get();

      final rankedCharacterRow =
          await (select(rankedCharacters)
            ..where((p) => p.characterId.equals(characterRow.id))).get();
      final sortOrder =
          rankedCharacterRow.isNotEmpty
              ? rankedCharacterRow.first.sortOrder
              : 0;

      allCharacters.add(
        CharacterData(
          id: characterRow.id,
          animeId: characterRow.animeId,
          animeName: characterRow.animeName,
          name: characterRow.name,
          pictures: pictures.map((p) => Uri.parse(p.pictureUri)).toList(),
          sortOrder: sortOrder,
        ),
      );
    }

    return allCharacters;
  }

  Future<void> insertCharacter(
    CharacterData character,
    List<Uri> pictures,
  ) async {
    // Insert character first
    await into(characters).insertOnConflictUpdate(
      CharactersCompanion(
        id: Value(character.id),
        animeId: Value(character.animeId),
        animeName: Value(character.animeName),
        name: Value(character.name),
      ),
    );

    // Insert pictures
    for (final pictureUri in pictures) {
      await into(characterPictures).insertOnConflictUpdate(
        CharacterPicturesCompanion(
          characterId: Value(character.id),
          pictureUri: Value(pictureUri.toString()),
        ),
      );
    }
  }

  Future<void> rankCharacter(int characterId, int rank, int sortOrder) async {
    await into(rankedCharacters).insertOnConflictUpdate(
      RankedCharactersCompanion(
        characterId: Value(characterId),
        rank: Value(rank),
        sortOrder: Value(sortOrder),
      ),
    );
  }

  Future<CharacterData> _buildCharacterData(
    Character characterRow,
    RankedCharacter rankedCharacterRow,
  ) async {
    final pictures =
        await (select(characterPictures)
          ..where((p) => p.characterId.equals(characterRow.id))).get();

    return CharacterData(
      id: characterRow.id,
      animeId: characterRow.animeId,
      animeName: characterRow.animeName,
      name: characterRow.name,
      pictures: pictures.map((p) => Uri.parse(p.pictureUri)).toList(),
      sortOrder: rankedCharacterRow.sortOrder,
    );
  }

  JoinedSelectStatement<HasResultSet, dynamic> _createTiersQuery() {
    return select(rankedCharacters).join([
      innerJoin(
        characters,
        characters.id.equalsExp(rankedCharacters.characterId),
      ),
    ]);
  }

  Future<List<TierData>> _processTierResults(List<TypedResult> results) async {
    final groupedResults = <int, List<CharacterData>>{};

    for (final row in results) {
      final characterRow = row.readTable(characters);
      final rankedCharacterRow = row.readTable(rankedCharacters);

      final character = await _buildCharacterData(
        characterRow,
        rankedCharacterRow,
      );
      final rank = rankedCharacterRow.rank;

      groupedResults.putIfAbsent(rank, () => []).add(character);
    }

    return groupedResults.entries
        .map((entry) => TierData(rank: entry.key, characters: entry.value))
        .toList()
      ..forEach(
        (tier) =>
            tier.characters.sort((a, b) => a.sortOrder.compareTo(b.sortOrder)),
      )
      ..sort((a, b) => a.rank.compareTo(b.rank));
  }

  Future<List<TierData>> getTiers() async {
    final results = await _createTiersQuery().get();
    return _processTierResults(results);
  }

  Stream<List<TierData>> getTiersStream() {
    return _createTiersQuery().watch().asyncMap(_processTierResults);
  }

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onUpgrade: stepByStep(
        from1To2: (m, schema) async {
          await m.addColumn(
            schema.rankedCharacters,
            schema.rankedCharacters.sortOrder,
          );
          await m.alterTable(TableMigration(schema.rankedCharacters));
        },
        from2To3: (m, schema) async {
          // insert into table, ignore duplicates
          await m.alterTable(
            TableMigration(
              schema.characterPictures,
              columnTransformer: {
                schema.characterPictures.pictureUri: schema
                    .characterPictures
                    .pictureUri
                    .collate(Collate.rTrim),
              },
            ),
          );
        },
      ),
      beforeOpen: (details) async {
        // Make sure that foreign keys are enabled
        await customStatement('PRAGMA foreign_keys = ON');

        // This follows the recommendation to validate that the database schema
        // matches what drift expects (https://drift.simonbinder.eu/docs/advanced-features/migrations/#verifying-a-database-schema-at-runtime).
        // It allows catching bugs in the migration logic early.
        if (kDebugMode) {
          await impl.validateDatabaseSchema(this);
        }
      },
    );
  }
}

// Data classes for the API
class CharacterData {
  final int id;
  final int animeId;
  final String animeName;
  final String name;
  final List<Uri> pictures;
  final int sortOrder;

  const CharacterData({
    required this.id,
    required this.animeId,
    required this.animeName,
    required this.name,
    required this.pictures,
    required this.sortOrder,
  });

  CharacterData copyWith({int? sortOrder}) {
    return CharacterData(
      id: id,
      animeId: animeId,
      animeName: animeName,
      name: name,
      pictures: pictures,
      sortOrder: sortOrder ?? this.sortOrder,
    );
  }
}

class TierData {
  final int rank;
  final List<CharacterData> characters;

  const TierData({required this.rank, required this.characters});
}
